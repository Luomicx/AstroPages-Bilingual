---
title: Java学习 - day002
tags: []
copyright: true
date: 2025-06-04 23:20:40
permalink:
categories: Java
description:
ogImage: http://img.wiretender.top/img/20250505193729283.webp
mathjax: true
katex: true
---



# Java 学习笔记

## 对象的成员方法

![image-20250505193728749](http://img.wiretender.top/img/20250505193729283.webp) 当程序执行到方法时，就会开辟一个独立的空间（**栈空间**)

```java
package javahsp.day04;

public class Method01 {
	public static void main(String[] args) {
		Person wangXinNuo = new Person();
		wangXinNuo.speak();
		wangXinNuo.cal01();
		wangXinNuo.cal02(10);
	}
}

class Person {
	String name;
	int age;

	// 1.public 公开方法
	// 2. void 无返回值
	// 3. speak 方法名 （） 形参列表
	// 4. {} 方法体 要执行的代码
	public void speak() {
		System.out.println("我是一个好人");
	}
	
	public void cal01() {
		int res = 0;
		for (int i = 1;i <= 100;i ++) {
			res += i;
		}
		System.out.println("计算结果 = " + res);
	}
	// (int end) 形参列表， 表示当前有一个形参，可以接受用户输入
	public void cal02(int end) {
		int res = 0;
		for (int i = 1;i <= end;i ++) {
			res += i;
		}
		System.out.println(" 计算结果 = " + res);
	}
	public int getSum(int num1, int num2) {
		int res = num1 + num2;
		return res;
	}
}

```

## 递归

```java
package javahsp.day04;

public class RecursionExercise01 {
	public static void main(String[] args) {
		T t1 = new T();
		System.out.println("斐波那契数字:" + t1.fibonacci(8));
	}
}

class T {
	public int fibonacci(int n) {
		if (n >= 1) {
			if (n == 1 || n == 2) {
				return 1;
			} else {
				return fibonacci(n-1) + fibonacci(n-2);
			}
		} else {
			System.out.println("要求输入 >= 1的正整数");
			return -1;
		}
			
		
	}
}

```

## 继承

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问

2. 子类必须调用父类的构造器，完成父类的初始化 

3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无 参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过(怎么理解。)[举例说明] 

4. 4.如果希望指定去调用父类的某个构造器，则显式的调用一下: super(参数列表)

5. super 在使用时，必须放在构造器第一行(super 只能在构造器中使用) 

6) super()和 this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

7) java 所有类都是 Object 类的子类, Object 是所有类的基类. 

8) 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) 

9) 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。

    思考：如何让 A 类继承 B 类和 C 类？【A 继承 B，B 继承 C】 

10) 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

### 练习

```java
package com.hspedu._extend;

public class ExtendsExercise03 {
    public static void main(String[] args) {
        PC pc = new PC("intel", 16, 500, "IBM");
        pc.printInfo();
    }
}

```

```java
package com.hspedu._extend;

public class Computer {
    private String cpu;
    private int memory;
    private int disk;

    public Computer() {

    }

    public Computer(String cpu, int memory, int disk) {
        this.cpu = cpu;
        this.memory = memory;
        this.disk = disk;
    }

    public String getDetails() {
        return " cpu=" + cpu + " memory=" + memory + " disk=" + disk;
    }

    public int getMemory() {
        return memory;
    }

    public void setMemory(int memory) {
        this.memory = memory;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public int getDisk() {
        return disk;
    }

    public void setDisk(int disk) {
        this.disk = disk;
    }
}

```

```java
package com.hspedu._extend;

public class PC extends Computer {
    private String brand;
    // IDEA 根据继承的规则，自动将构造器的调用写好了
    // 也体现出一个设计的基本思想，父类的构造器完成父类属性初始化
    // 子类完成子类属性的初始化
    public PC(String cpu, int memory, int disk, String brand) {
        super(cpu, memory, disk);
        this.brand = brand;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public void printInfo() {
        System.out.println("PC信息 = ");
//        System.out.println(getCpu() + getMemory() + getBrand());
        System.out.println(getDetails() + " brand = " + brand);
    }


}

```

## 多态

- 多态就是为了解决代码的重复问题，我们通过向下转型和向上转型的两种方法来实现面向对象中的多态。

### 多态的应用-多态数组

- `instanceof` 判断运行类型是什么

```java
if (person[i] instanceof Student) { // 判断当前的person[i]类型是否为学生
    Student student = (Student)person[i]; // 向下转型，多态的 体现
    student.study();
} 
```

# 多态参数

```java 
package com.hspedu.poly_.polyparameter;

public class PloyParameter {
    public static void main(String[] args) {
        Worker tom = new Worker(2500,"tom");
        Manager milan = new Manager(5000, "milan", 250000);
        PloyParameter ployParameter = new PloyParameter();
        ployParameter.showEmpAnnual(tom);
        ployParameter.showEmpAnnual(milan);
        ployParameter.testWork(tom);
        ployParameter.testWork(milan);
    }

    public void showEmpAnnual(Employee e) {
        System.out.println(e.getAnnual());
    }

    public void testWork(Employee e) {
        if (e instanceof Worker) {
            ((Worker) e).work();
        } else if (e instanceof Employee) {
            ((Manager) e).manage();
        } else {
            System.out.println("不做处理 ...");
        }
    }
}

```

```java
package com.hspedu.poly_.polyparameter;


public class Employee {
    private String name;
    private double salary;

    public Employee(double salary, String name) {
        this.salary = salary;
        this.name = name;
    }
    public double getAnnual() {
        return 12 * salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}

```

```java
package com.hspedu.poly_.polyparameter;

public class Worker extends Employee {
    public Worker(double salary, String name) {
        super(salary, name);
    }
    public void work() {
        System.out.println("员工" + getName() + "is working");
    }

    @Override
    public double getAnnual() {
        return super.getAnnual();
    }
}

```

```java
package com.hspedu.poly_.polyparameter;

public class Manager extends Employee {
    private double bonus;

    public Manager(double salary, String name, double bonus) {
        super(salary, name);
        this.bonus = bonus;
    }

    public void manage() {
        System.out.println("经理 " + getName() + "is managing");
    }
    public double getBonus() {
        return bonus;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    @Override
    public double getAnnual() {
        return super.getAnnual() + bonus;
    }
}

```

